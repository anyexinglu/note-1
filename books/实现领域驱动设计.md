# 实现领域驱动设计

最近在看`实现领域驱动设计`，记录看到的一些不错的话语。

- 在实施 DDD 时，设计就是代码，代码就是设计。
- 通用语言是团队自己创建的公用语言，团队中同时包含领域专家和软件开发人员。

白板时间

- 对于你目前正在工作的业务领域，思考一下模型中的通用术语和业务操作。
- 将术语写在白板上。
- 然后，将项目中所用到的短语也写下来。
- 与真正的领域专家交流一下，看看哪些词汇是可以改善的（记得带上咖啡哦）。

> 为了分配任务而拆分限界上下文是一种错误的上下文建模方式

## 上下文映射图

上下文映射图表现是项目当前的状态，如果项目会在将来发生变化，你可以到那时才对上下文映射图做相应的更新。关注于当前的项目状态可以帮助你了解你正处的位置，并帮助你决定如何走出下一步。

上下文映射图并不是一种企业架构，也不是系统拓扑图。但是，它可以用于高层次的架构分析，指出诸如集成瓶颈之类的架构不足。上下文映射图展现了一种组织动态能力，它可以帮助我们识别出有碍项目进展的一些管理问题。

上下文映射图中，我们使用以下缩写来表示各种关系：

- ACL 表示防腐层
- OHS 表示开放主机服务
- PL 表示发布语言

## 架构

依赖倒置原则

- 高层模块不应该依赖于底层模块，两者都应该依赖于抽象
- 抽象不应该依赖于细节，细节应该依赖于抽象

DDD 与 REST 结合

- 第一种方法：为系统接口层单独创建一个限界上下文，再在此上下文中通过适当的策略来访问实际的核心模型。
- 使用标准媒体类型

命令和查询职责分离 - CQRS

> 一个方法要么是执行某种动作的命令，要么是返回数据的查询，而不能两者皆是。

在对象层面，意味着：

1. 如果一个方法修改了对象的状态，该方法便是一个命令，它不应该返回数据。
2. 如果一个方法返回来数据，该方法便是一个查询，此时它不应该通过直接的或间接的手段修改对象的状态。

## 实体

唯一的身份标识和可变性特征将实体对象和`值对象`区分开来。

如果实体的不变条件要求该实体所包含的对象都不能为 null 状态，或者由其他状态计算所得，那么这些状态需要作为参数传递给构造函数。

## 值对象

我们应该尽量使用`值对象`来建模而不是实体对象，你可能对此非常惊讶。即便一个领域概念必须建模成实体，在设计时也应该更偏向于将其作为值对象容器，而不是子实体容器。这并不是源自于无端的偏好，而是因为我们可以非常容易的对值对象进行创建、测试、使用、优化和维护。

> 当你只关心某个对象的属性时，该对象便可作为一个值对象。为其添加有意义的属性，并赋予它相应的行为。我们需要将值对象看成不变对象，不要给它任何身份标识，还应该尽量避免像实体对象一样的复杂性。

一个领域概念是否是一个值对象？需要考虑它是否拥有以下特征：

- 它度量或者描述了领域中的一件东西。
- 它可以作为不变量。
- 它将不同的相关的属性组合成一个概念整体。
- 当度量和描述改变时，可以用另一个值对象予以替换。
- 它可以和其他值对象进行相等性比较。
- 它不会对协作对象造成副作用。

值对象的构造函数用于保证概念整体的有效性和不变性。

可以对值对象进行完全的替换而不是通过内部的方法来修改属性，这样就违反了不变性。

```java
FullName name = new FullName('Vaughn', 'Vernon')

// 替换
name = new FullName('Vaughn', 'L', 'Vernon')
```

值对象相等性：在比较两个值对象时，需要检查这两个值对象的相等性。相等性通过比较两个对象的类型和属性来决定，如果两个对象的类型和属性都相等，那么这两个对象也是相等的。

## 领域服务
